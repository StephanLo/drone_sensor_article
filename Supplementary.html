<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Albertus S. Louw">
<meta name="author" content="Chen Xinyu">
<meta name="author" content="Ram Avtar">

<title>Supplementary File 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="Supplementary_files/libs/clipboard/clipboard.min.js"></script>
<script src="Supplementary_files/libs/quarto-html/quarto.js"></script>
<script src="Supplementary_files/libs/quarto-html/popper.min.js"></script>
<script src="Supplementary_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Supplementary_files/libs/quarto-html/anchor.min.js"></script>
<link href="Supplementary_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Supplementary_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Supplementary_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Supplementary_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Supplementary_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="Supplementary.docx"><i class="bi bi-file-word"></i>MS Word</a></li><li><a href="Supplementary.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="Supplementary.pdf"><i class="bi bi-file-pdf"></i>PDF (elsevier)</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Supplementary File 1</h1>
<p class="subtitle lead">Article: On the accuracy of infrared-converted drone cameras for use in vegetation and environmental monitoring</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Albertus S. Louw </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Graduate School of Environmental Science, Hokkaido University
          </p>
      </div>
      <div class="quarto-title-meta-contents">
    <p class="author">Chen Xinyu </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Graduate School of Environmental Science, Hokkaido University
          </p>
      </div>
      <div class="quarto-title-meta-contents">
    <p class="author">Ram Avtar </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Graduate School of Environmental Science, Hokkaido University
          </p>
      </div>
    </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  

</header>

<p>This supplementary file describes in more detail the processing steps used to generate the results of the study, to support reproducibility of the results.</p>
<section id="camera-characteristics" class="level2">
<h2 class="anchored" data-anchor-id="camera-characteristics">Camera characteristics</h2>
<p>Additional information on the camera parameters used for the infrared converted camera (Mapir Survey 3W OCN) and multispectral camera (MicaSense RedEdge-M) used during the study.</p>
<table class="table">
<caption>Camera sensor characteristics and parameter settings during field surveys</caption>
<colgroup>
<col style="width: 34%">
<col style="width: 25%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Characteristic</th>
<th>Mapir Survey 3W OCN</th>
<th>MicaSense RedEdge-M</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bit depth</td>
<td>12</td>
<td>16</td>
</tr>
<tr class="even">
<td>Capture mode</td>
<td>RAW</td>
<td>RAW</td>
</tr>
<tr class="odd">
<td>Image Resolution (px)</td>
<td>4000 x 3000</td>
<td>1280 x 960</td>
</tr>
<tr class="even">
<td>F-stop</td>
<td>f/2.8</td>
<td>f/2.8</td>
</tr>
<tr class="odd">
<td>ISO</td>
<td>100</td>
<td>Not recorder in image metadata</td>
</tr>
<tr class="even">
<td>Shutter Speed (sec)</td>
<td>1/500</td>
<td>variable</td>
</tr>
<tr class="odd">
<td>Focal length (mm)</td>
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="radiometric-calibrations-and-photogrammetry" class="level2">
<h2 class="anchored" data-anchor-id="radiometric-calibrations-and-photogrammetry">Radiometric calibrations and photogrammetry</h2>
<section id="mapir-survey-3w-ocn" class="level3">
<h3 class="anchored" data-anchor-id="mapir-survey-3w-ocn">Mapir Survey 3W OCN</h3>
<p>Mapir supplies radiometric calibration software for the Mapir Survey 3W camera in the form of graphical user interface program, and alternatively a suit of python based programming scripts. However, the Mapir Camera Control software did not support vignette corrections for our camera model, and thus we used the supplied python based scripts for radiometric calibration. A custom Windows Batch script was written to automatically calibrate large sets of RAW image files to reflectance images, using the python scripts and python conda environment provided by Mapir <span class="citation" data-cites="mapirsc2020">(<a href="#ref-mapirsc2020" role="doc-biblioref"><span>“Mapir Scripts Manual”</span> 2020</a>)</span> . Our batch script sequentially executes the following three steps:</p>
<ol type="1">
<li>Convert RAW images to tiff files,</li>
<li>Apply Vignette corrections (FlatField Correction)</li>
<li>Calibration to reflectance, using reflectance panel image captured prior to flight.</li>
</ol>
<p>The outputted reflectance images are stored as 16-bit byte images, so to obtain reflectance values (float values typically between 0 and 1) the outputted images need to be divided by the bit depth (i.e., <span class="math inline">\(2^{16} -1 = 65535\)</span>). The folder with python scripts, windows batch file (raw_to_calibrated_S3W.bat), and directory structure used for the batch processing is available on github at the following URL: <a href="https://github.com/StephanLo/drone_sensor_article/tree/main/processing/mapir-scripts">https://github.com/StephanLo/drone_sensor_article/tree/main/processing/mapir-scripts</a>.</p>
<p>Following radiometric calibration of all images, the drone photogrammetry software OpenDroneMap was used to create a georeferenced orthomosaic of the study site. OpenDroneMap is an open-source software, available on Github, from <a href="https://github.com/OpenDroneMap/ODM" title="https://github.com/OpenDroneMap/ODM">ODM link</a>. The software’s standalone Windows command line utility was used in this study, which can be accessed from <a href="https://github.com/OpenDroneMap/ODM/releases" title="https://github.com/OpenDroneMap/ODM/releases">here</a>.</p>
<p>The command line options used for the Mapir camera dataset are shown below. Notably, target orthophoto resolution is set to a ground sampling distance of 5 cm per pixel. Radiometric calibration options are not enabled, since radiometric calibrations were manually conducted with the Mapir provided software.</p>
<p><code>Run --orthophoto-resolution 5 --fast-orthophoto --time "path\to\project\folder"</code></p>
</section>
<section id="micasense-rededge-m" class="level3">
<h3 class="anchored" data-anchor-id="micasense-rededge-m">MicaSense RedEdge-M</h3>
<p>Individual MicaSense images used in the analysis were calibrated by python image processing libraries provided by MicaSense, using tutorials and scripts on this <a href="https://micasense.github.io/imageprocessing/" title="https://micasense.github.io/imageprocessing/">website</a>.</p>
<p>However, the stacked Tiff files created by these processing modules are at the time of writing not supported by the drone image processing software OpenDroneMap, as explained in this <a href="https://community.opendronemap.org/t/error-processing-stacked-tiff-output-from-micasense-imageprocessing/7195" title="https://community.opendronemap.org/t/error-processing-stacked-tiff-output-from-micasense-imageprocessing/7195">forum</a>. OpenDroneMap supports radiometric calibration of MicaSense Red-Edge images, however the calibration does not utilise data from the MicaSense provided reflectance panels. Instead it uses data from the downwelling light sensor attached to the camera to correct the images for illumination conditions. The output of this processing generated reflectance values with a different scale than the outputs of the MicaSense provided calibration workflow, presumably because of the difference in luminosity recorded by the downwelling light sensor and reflectance panels respectively. However, the effect of luminosity only results in a linear scaling difference in the reported reflectance values (because of the Empirical Line Calibration method used by the software), and thus the results could still effectively be used for other analysis and derivation of vegetation indices.<br>
The Open drone map command-line options used for the MicaSense dataset is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">run</span> <span class="at">--orthophoto-resolution</span> 5 <span class="at">--fast-orthophoto</span> <span class="at">--radiometric-calibration</span> camera+sun <span class="st">"Path\to\project\folder"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="georectification-and-post-processing" class="level2">
<h2 class="anchored" data-anchor-id="georectification-and-post-processing">Georectification and post processing</h2>
<p>To ensure that generated orthomosaics aligned precisely, they were manually georectified. One orthophoto, the MicaSense Red-Edge orthophoto from the 2022/07/05 field survey was considered as basemap, and after that other 3 orthophotos were georectified to the chosen basemap, by matching 6 or 7 corresponding points in the scene. Two open-source software were used: QGIS Georeferencer, and the GRASS GIS Georectification utility (<em>module:</em> <em>g.gui.gcp</em>). Suitable results were obtained using a Helmert Transformation with cubic resampling, and no compression for output files, to maintain data integrity. The JDG2011 UTM 54N coordinate reference system (epsg: 6691) was used for the resulting orthomosaics.</p>
</section>
<section id="derivation-of-ndvi" class="level2">
<h2 class="anchored" data-anchor-id="derivation-of-ndvi">Derivation of NDVI</h2>
<p>The red-channel and near-infrared channels of the two sensors were used to generate NDVI maps of the study fields, using the following code scripts in R:</p>
<p>The Generated NDVI maps and orthorectified imagery are then further analysed, as described in the main text, with analysis scripts given in the corresponding manuscript.qmd file, or manuscript_verbose.html</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-mapirsc2020" class="csl-entry" role="listitem">
<span>“Mapir Scripts Manual.”</span> 2020. <a href="https://mapir.gitbook.io/mapir-scripts/">https://mapir.gitbook.io/mapir-scripts/</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>